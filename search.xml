<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>halo安装部署</title>
      <link href="/2024/06/09/halo%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
      <url>/2024/06/09/halo%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1>安装Docker</h1><p><strong>使用终端命令安装Docker</strong></p><p><strong>更新yum</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><p><strong>卸载旧版本：</strong></p><p>列出安装过的 Docker 包：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum list installed | grep docker</span><br></pre></td></tr></table></figure><p>旧版名称是 Docker，最新社区版 docker-engine， 目前已改名为docker-ce</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y remove docker docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure><p><strong>设置yum源：</strong></p><p>本文以 yum 安装为例子进行安装安装 yum-utils，使用 yum-config-manager 工具设置 yum 源，后面两个是 devicemapper 驱动依赖</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>使用阿里源访问</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p><strong>安装Docker</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure><p>安装成功</p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2Fhalo2%E5%AE%89%E8%A3%85.assets%2Fimage-20240607150152740.png" alt="image-20240607150152740"></p><p><strong>启动Docker,并加入开启自启</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker     启动  </span><br><span class="line">systemctl restart docker   重启</span><br><span class="line">systemctl enable docker    开机启动</span><br></pre></td></tr></table></figure><p>执行 docker version 查看 Docker 版本号。</p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2Fhalo2%E5%AE%89%E8%A3%85.assets%2Fimage-20240607150203715.png" alt="image-20240607150203715"></p><p>并且最新的docker 已经集成了 docker compose</p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2Fhalo2%E5%AE%89%E8%A3%85.assets%2Fimage-20240607150210993.png" alt="image-20240607150210993"></p><h1>安装halo</h1><h2 id="创建-halo-目录"><strong>创建 halo 目录</strong></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ~/halo &amp;&amp; cd ~/halo</span><br></pre></td></tr></table></figure><h2 id="创建-docker-compose-yaml"><strong>创建 <code>docker-compose.yaml</code></strong></h2><p>此处我们使用 mysql 作为数据库</p><p>docker-compose.yaml 的内容如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  halo:</span><br><span class="line">    image: halohub/halo:2.16</span><br><span class="line">    restart: on-failure:3</span><br><span class="line">    depends_on:</span><br><span class="line">      halodb:</span><br><span class="line">        condition: service_healthy</span><br><span class="line">    networks:</span><br><span class="line">      halo_network:</span><br><span class="line">    volumes:</span><br><span class="line">      - ./halo2:/root/.halo2</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8090:8090&quot;</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8090/actuator/health/readiness&quot;]</span><br><span class="line">      interval: 30s</span><br><span class="line">      timeout: 5s</span><br><span class="line">      retries: 5</span><br><span class="line">      start_period: 30s</span><br><span class="line">    command:</span><br><span class="line">      - --spring.r2dbc.url=r2dbc:pool:mysql://halodb:3306/halo</span><br><span class="line">      - --spring.r2dbc.username=root</span><br><span class="line">      # MySQL 的密码，请保证与下方 MYSQL_ROOT_PASSWORD 的变量值一致。</span><br><span class="line">      - --spring.r2dbc.password=o#DwN&amp;JSa56</span><br><span class="line">      - --spring.sql.init.platform=mysql</span><br><span class="line">      # 外部访问地址，请根据实际需要修改</span><br><span class="line">      - --halo.external-url=http://localhost:8090/</span><br><span class="line"></span><br><span class="line">  halodb:</span><br><span class="line">    image: mysql:8.1.0</span><br><span class="line">    restart: on-failure:3</span><br><span class="line">    networks:</span><br><span class="line">      halo_network:</span><br><span class="line">    command: </span><br><span class="line">      - --default-authentication-plugin=caching_sha2_password</span><br><span class="line">      - --character-set-server=utf8mb4</span><br><span class="line">      - --collation-server=utf8mb4_general_ci</span><br><span class="line">      - --explicit_defaults_for_timestamp=true</span><br><span class="line">    volumes:</span><br><span class="line">      - ./mysql:/var/lib/mysql</span><br><span class="line">      - ./mysqlBackup:/data/mysqlBackup</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: [&quot;CMD&quot;, &quot;mysqladmin&quot;, &quot;ping&quot;, &quot;-h&quot;, &quot;127.0.0.1&quot;, &quot;--silent&quot;]</span><br><span class="line">      interval: 3s</span><br><span class="line">      retries: 5</span><br><span class="line">      start_period: 30s</span><br><span class="line">    environment:</span><br><span class="line">      # 请修改此密码，并对应修改上方 Halo 服务的 SPRING_R2DBC_PASSWORD 变量值</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=o#DwN&amp;JSa56</span><br><span class="line">      - MYSQL_DATABASE=halo</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  halo_network:</span><br></pre></td></tr></table></figure><h2 id="启动-Halo">启动 Halo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker compose up -d  </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker compose logs -f</span><br></pre></td></tr></table></figure><p>用浏览器访问 /console 即可进入 Halo 管理页面，首次启动会进入初始化页面。</p><p>后续如果需要修改 halo 的配置，直接更新 docker-compose.yaml 后重新启动容器即可</p><p><strong>如果遇到DockerHub被DNS污染的情况，会拉取不到镜像，那就取ghcr.io上拉取halo的镜像</strong></p><h1>nginx 反向代理</h1><h2 id="安装nginx">安装nginx</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install nginx         #安装</span><br><span class="line">sudo systemctl start nginx     #启动</span><br><span class="line">sudo systemctl enable nginx    #开机自启</span><br></pre></td></tr></table></figure><h2 id="配置反向代理">配置反向代理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream halo &#123;</span><br><span class="line">  server 127.0.0.1:8090;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  listen [::]:80;</span><br><span class="line">  server_name www.yourdomain.com;</span><br><span class="line">  client_max_body_size 1024m;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://halo;</span><br><span class="line">    proxy_set_header HOST $host;</span><br><span class="line">    proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，halo2是用java写的，相比于带后端的其他博客系统，比如typecho，wordpress来说，还是比较吃内存的，一个mysql容器，一个halo容器，一个nginx，占用了1G多内存，没办法，java应用是这样的</p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2Fhalo2%E5%AE%89%E8%A3%85.assets%2Fimage-20240607150434494.png" alt="image-20240607150434494"></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC知识点</title>
      <link href="/2024/06/08/JUC%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2024/06/08/JUC%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309202706043.png" alt="image-20240309202706043" style="zoom: 67%;" /><p><strong>在JAVA中，当我们启动main函数时，实际上会启动一个<mark>JVM进程</mark>，main函数所在的线程就是这个进程的<mark>主线程</mark>。</strong></p><p><strong>并发编程的<mark>三个重要特性</mark>：原子性、可见性、有序性</strong></p><ul class="lvl-0"><li class="lvl-2"><p><strong>原子性</strong>：使用<code>sychronized</code>、各种<code>lock</code>保证原子性</p></li><li class="lvl-2"><p><strong>可见性</strong>：当一个线程对<code>共享变量</code>修改后，另外的线程都是可以立即看到修改后的最新值。使用<code>sychronized</code>、<code>volatile</code>、<code>lock</code>实现可见性。</p></li><li class="lvl-2"><p><strong>有序性</strong>：指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致，所以在多线程下，指令重排序可能会导致一些问题，我们可以使用<code>volatile</code>关键字来禁止指令重排序。</p></li></ul><h2 id="多线程">多线程</h2><h3 id="进程和线程的区别">进程和线程的区别</h3><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309204137587.png" alt="image-20240309204137587"></p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309204253422.png" alt="image-20240309204253422" style="zoom: 50%;" /><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309204402331.png" alt="image-20240309204402331"></p><h3 id="并发和并行">并发和并行</h3><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309204819989.png" alt="image-20240309204819989"></p><h3 id="创建线程的方式">创建线程的方式</h3><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309205219858.png" alt="image-20240309205219858" style="zoom:50%;" /><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309205830743.png" alt="image-20240309205830743" style="zoom: 50%;" /><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309205943877.png" alt="image-20240309205943877" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//匿名内部类，在Thread()中传入实现了Rannable接口的实例</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309210310343.png" alt="image-20240309210310343" style="zoom: 50%;" /><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309210624669.png" alt="image-20240309210624669" style="zoom: 50%;" /><h4 id="Runnable和Callable有什么区别">Runnable和Callable有什么区别</h4><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309210918913.png" alt="image-20240309210918913"></p><h4 id="run-和-start-的区别">run() 和 start()的区别</h4><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309211337601.png" alt="image-20240309211337601"></p><h3 id="线程的状态及转化">线程的状态及转化</h3><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309211842592.png" alt="image-20240309211842592" style="zoom: 67%;" /><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309212837104.png" alt="image-20240309212837104"></p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309212920842.png" alt="image-20240309212920842"></p><h3 id="如何控制线程的运行顺序-join">如何控制线程的运行顺序 join()</h3><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309213722393.png" alt="image-20240309213722393"></p><h3 id="notify-和notifyall">notify()和notifyall()</h3><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240309214010249.png" alt="image-20240309214010249" style="zoom:50%;" /><h3 id="sleep-和wait-⭐">sleep()和wait() ⭐</h3><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310140600006.png" alt="image-20240310140600006" style="zoom:67%;" /><h3 id="停止线程">停止线程</h3><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310142855985.png" alt="image-20240310142855985" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用标志退出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterrupt1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span> ;     <span class="comment">// 线程执行的退出标记</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyThread对象</span></span><br><span class="line">        <span class="type">MyInterrupt1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterrupt1</span>() ;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠6秒</span></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更改标记为true</span></span><br><span class="line">        t1.flag = <span class="literal">true</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用interrupt方法中断线程</span></span><br><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterrupt3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.打断阻塞的线程</span></span><br><span class="line">        <span class="comment">/*Thread t1 = new Thread(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;t1 正在运行...&quot;);</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                Thread.sleep(5000);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;, &quot;t1&quot;);</span></span><br><span class="line"><span class="comment">        t1.start();</span></span><br><span class="line"><span class="comment">        Thread.sleep(500);</span></span><br><span class="line"><span class="comment">        t1.interrupt();</span></span><br><span class="line"><span class="comment">        System.out.println(t1.isInterrupted());*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.打断正常的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> current.isInterrupted();</span><br><span class="line">                <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;打断状态：&quot;</span>+interrupted);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"><span class="comment">//        t2.interrupt();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized底层原理">synchronized底层原理</h2><h3 id="基本使用">基本使用</h3><p><strong>注意：sychronized只能满足单个jvm下的锁，多个jvm下需要分布式锁，如同一个服务，但是做了集群，他们就位于不同的jvm中</strong></p><p>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住</p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310143751088.png" alt="image-20240310143751088"></p><p><mark><strong>使用方式</strong>：</mark></p><ul class="lvl-0"><li class="lvl-2"><p><strong>修饰实例方法（锁当前对象实例）</strong><br>给当前对象实例加锁，进入同步代码前要先获得当前对象的实例锁</p></li><li class="lvl-2"><p><strong>修饰静态方法（锁当前类）</strong><br>给当前类加锁，会作用于类的所有实例对象，进入同步代码前要先获得当前class的锁，因为静态成员变量不属于任何一个实例，而是属于整个类，被类的所用实例共享。</p><p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p></li><li class="lvl-2"><p><strong>修饰代码块（锁指定对象/类）</strong><br>对括号里的 类/对象 加锁</p><p><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</p><p><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></p></li><li class="lvl-2"><p><strong>构造方法能用 <code>synchronized</code> 修饰吗？</strong><br>不能，但构造方法内可以使用 <code>synchronized</code> 代码块另外，构造方法本身是线程安全的，但如果在构造方法中涉及到共享资源的操作，就需要采取适当的同步措施来保证整个构造过程的线程安全</p></li></ul><h3 id="底层原理">底层原理</h3><p>synchronized 关键字底层原理属于 JVM 层面的东西。</p><p>Monitor 被翻译为监视器，由jvm提供，c++语言实现</p><h4 id="修饰同步代码块的情况">修饰同步代码块的情况</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为上述代码字节码文件的一部分，可以看到，<strong>包含两个monitorexit</strong>，这是为了保证同步代码块正常执行以及出现异常时，同步锁可以正常释放。</p><p>当执行monitorenter指令时，<strong>线程</strong>会试图获取锁，也就是获取<strong>对象监视器</strong><code>monitor</code>的特有权。</p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240503193419346-1716727704727-17.png" alt="image-20240503193419346" style="zoom: 67%;" /><p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由<code>ObjectMonitor</code>实现的。<strong>每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</strong></p><p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么<strong>只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则</strong>会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310144605392.png" alt="image-20240310144605392"></p><p>具体的流程：</p><ul class="lvl-0"><li class="lvl-2"><p>代码进入synchorized代码块，<mark>先让lock（对象锁）关联monitor</mark>，然后判断Owner是否有线程持有</p></li><li class="lvl-2"><p>如果没有线程持有，则让当前线程持有，表示该线程获取锁成功</p></li><li class="lvl-2"><p>如果有线程持有，则让当前线程进入entryList进行阻塞，如果Owner持有的线程已经释放了锁，在EntryList中的线程去<mark>竞争</mark>锁的持有权==（非公平）==</p></li><li class="lvl-2"><p>如果代码块中调用了wait()方法，则会进去WaitSet中进行等待</p></li></ul><p>参考回答：</p><ul class="lvl-0"><li class="lvl-2"><p>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</p></li><li class="lvl-2"><p>它的底层由monitor实现的，<strong>monitor是jvm级别的对象（ C++实现）</strong>，线程获得锁需要使用对象（锁）关联monitor</p></li><li class="lvl-2"><p>在monitor内部有三个属性，分别是owner、entrylist、waitset</p></li><li class="lvl-2"><p>其中owner是关联的获得锁的线程，并且只能关联一个线程；entrylist关联的是处于阻塞状态的线程；waitset关联的是处于Waiting状态的线程</p></li></ul><h4 id="修饰方法的情况">修饰方法的情况</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240606183136051.png" alt="image-20240606183136051" style="zoom:50%;" /><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p><strong>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁</strong></p><p><strong>总结</strong></p><ul class="lvl-0"><li class="lvl-2"><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p></li><li class="lvl-2"><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p></li></ul><h3 id="锁升级">锁升级</h3><p>首先，锁的状态有4中：<strong>无锁状态</strong>、<strong>偏向锁</strong>、<strong>轻量级锁</strong>、<strong>重量级锁</strong>。这些都记录在锁对象的<strong>Mark Word</strong>中。随着锁竞争的激烈程度上升，锁会升级，但不会降级。</p><ul class="lvl-0"><li class="lvl-2"><p><strong>偏向锁</strong><br>偏向于第一个请求锁的线程。</p><ul class="lvl-2"><li class="lvl-4">如果在运行过程中，同步锁只有一个线程请求，不存在锁竞争的情况，则会给该线程加一个偏向锁（将线程id记录在锁对象mark word中），当该线程下次执行同步代码块时，会判断当前持有锁的线程是否是自己。如果自始至终都没有锁竞争，那么偏向锁不会有额外的开销，效率很高。</li><li class="lvl-4">如果运行过程中发生了锁竞争，则持有偏向锁的线程会被挂起，JVM会消除他的偏向锁，将锁升级为轻量级锁，撤销轻量级锁时会导致STW。</li></ul></li><li class="lvl-2"><p><strong>轻量级锁（自旋锁）</strong></p><ul class="lvl-2"><li class="lvl-4">升级为轻量级锁后，竞争失败的线程会导致锁进入<strong>锁膨胀</strong>状态，会让竞争失败的线程自旋，自旋会导致<strong>忙等</strong>问题，当自旋达到一定次数后，轻量级锁升级为重量级锁。</li><li class="lvl-4">自旋的好处是，减少了线程状态切换带来的开销，缺点是可能会占用CPU资源。</li></ul></li><li class="lvl-2"><p><strong>重量级锁</strong></p><ul class="lvl-2"><li class="lvl-4">当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则自己会直接进入阻塞状态。</li></ul></li></ul><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240606185236557.png" alt="image-20240606185236557" style="zoom:50%;" /><h2 id="volatile">volatile</h2><h3 id="保证线程间的可见性">保证线程间的可见性</h3><p>如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，<mark>每次使用它都到<strong>主存中进行读取</strong></mark></p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310154147808.png" alt="image-20240310154147808"></p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310154540702.png" alt="image-20240310154540702" style="zoom:67%;" /><p>其实是加了<code>volatile</code>后，每次读写这个变量，都要到共享内存中读取</p><h3 id="禁止指令重排序">禁止指令重排序</h3><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310154929359.png" alt="image-20240310154929359"></p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310155651807.png" alt="image-20240310155651807"></p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310155852881.png" alt="image-20240310155852881" style="zoom:67%;" /><h4 id="双重校验锁-实现对象单例（线程安全）："><strong>双重校验锁 实现对象单例（线程安全）</strong>：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"><span class="comment">//私有化构造函数，不能 new 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li class="lvl-3"><p>为 <code>uniqueInstance</code> 分配内存空间</p></li><li class="lvl-3"><p>初始化 <code>uniqueInstance</code></p></li><li class="lvl-3"><p>将 <code>uniqueInstance</code> 指向分配的内存地址</p></li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><p>**<code>volatile</code> 关键字能保证变量的可见性，但<mark>不能保证对变量的操作是原子性的</mark>。**通常，对一个变量的修改包括三部：读取变量值，修改变量值，将修改后的值保存</p><h3 id="synchronized和volatile">synchronized和volatile</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p><ul class="lvl-0"><li class="lvl-2"><p><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</p></li><li class="lvl-2"><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p></li><li class="lvl-2"><p><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，和防止指令重排，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性</p></li></ul><h2 id="JMM-Java内存模型">JMM(Java内存模型)</h2><p><strong>JMM 定义了共享内存中多线程程序读写操作的行为规范。</strong></p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310151130003.png" alt="image-20240310151130003" style="zoom:67%;" /><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310151147324.png" alt="image-20240310151147324" style="zoom:67%;" /><p><strong>什么是主内存？什么是本地内存？</strong></p><ul class="lvl-0"><li class="lvl-2"><p><strong>主内存</strong>：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</p></li><li class="lvl-2"><p><strong>本地内存</strong>：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写==<strong>共享变量的副本</strong>==。**每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。如果线程间需要通信，必须通过主内存来进行。**本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p></li></ul><p>JMM为共享变量提供了可见性的保障。</p><p>主内存存放共享变量，工作内存存放共享变量副本。</p><h2 id="锁">锁</h2><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310153143150.png" alt="image-20240310153143150"></p><h3 id="悲观锁">悲观锁</h3><ul class="lvl-0"><li class="lvl-2"><p>悲观锁的基本思想是认为数据很可能会发生冲突，因此在访问数据之前先获取锁。在使用悲观锁的情况下，线程在访问共享资源之前会先尝试获取锁，如果获取不到锁就会进入阻塞状态，直到获取到锁为止。</p></li><li class="lvl-2"><p>悲观锁常常使用 synchronized 关键字或者是显式锁（如 ReentrantLock）来实现，它可以确保在同一时刻只有一个线程能够访问共享资源，从而保证数据的一致性。</p></li></ul><h4 id="AQS（公平的）">AQS（公平的）</h4><p>AbstractQueueSynchronizer ,抽象队列同步器，是构建锁或其他同步组件的基础框架</p><p><mark><strong>AQS 就是一个抽象类，主要用来构建锁和同步器。</strong></mark></p><p>常见的实现类：ReentrantLock、Semaphore、CountDownLatch</p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240606203510042.png" alt="image-20240606203510042" style="zoom:50%;" /><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310162708708.png" alt="image-20240310162708708" style="zoom: 67%;" /><h4 id="ReentrantLock">ReentrantLock</h4><p>基于JDK实现的锁，与<code>synchronized</code>相比具有以下特点：</p><ul class="lvl-0"><li class="lvl-2"><p>可中断</p></li><li class="lvl-2"><p>可重入（synchronized也可重入）</p></li><li class="lvl-2"><p>可设置公平锁</p></li><li class="lvl-2"><p>可设置超时时间</p></li><li class="lvl-2"><p>支持多个条件变量</p></li></ul><p><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</p><p>通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</p><p><strong>可重入锁</strong> 也叫递归锁，指的是<strong>同一个线程</strong>可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p><h5 id="底层原理-2">底层原理</h5><p>AQS+CAS</p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310164627977.png" alt="image-20240310164627977"></p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310165253810.png" alt="image-20240310165253810"></p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310165419183.png" alt="image-20240310165419183"></p><h5 id="synchronized-与-Lock的区别">synchronized 与 Lock的区别</h5><p><strong>语法层面</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p><code>synchronized</code> 是关键字，由 jvm 实现，用cpp实现</p></li><li class="lvl-2"><p><code>Lock</code> 是接口，由 JDK 提供，用 java 语言实现</p></li><li class="lvl-2"><p><code>synchornized</code> 退出同步块会自动释放锁，<code>Lock</code> 要手动 unlock</p></li></ul><p><strong>功能层面</strong></p><ul class="lvl-0"><li class="lvl-2"><p>都是悲观锁，具有基本的<strong>互斥、同步、重入</strong>功能</p></li><li class="lvl-2"><p><code>Lock</code> 可打断、可公平、可设置超时时间、多条件变量</p></li><li class="lvl-2"><p><code>Lock</code> 由适合不同场景的实现，如 ReentrantLock、ReentrantReadWriteLock</p></li></ul><p><strong>性能层面：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>没有竞争时，<code>synchronized</code> 做了很多优化，如偏向锁、轻量级锁，性能不错</p></li><li class="lvl-2"><p>竞争激烈时，Lock 性能更好</p></li></ul><h4 id="Semaphore">Semaphore</h4><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始共享资源数量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取1个许可</span></span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">// 释放1个许可</span></span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure><p><code>Semaphore</code> 通常用于那些<strong>资源有明确访问数量限制的场景</strong>比如限流（仅限于单机模式，实际项目中推荐使用 Redis +Lua 来做限流）。</p><h5 id="原理">原理</h5><p><code>Semaphore</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，你可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p><p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt;= 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 <strong>CAS</strong> 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果 <code>state&lt;0</code> 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。</p><h4 id="死锁">死锁</h4><p>死锁的四个必要条件</p><ul class="lvl-0"><li class="lvl-2"><p><strong>互斥条件</strong> ：该资源任意一个时刻只由一个线程占用。</p></li><li class="lvl-2"><p><strong>请求与保持条件</strong> ：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p></li><li class="lvl-2"><p>**不剥夺条件 **: 线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p></li><li class="lvl-2"><p>**循环等待条件 **: 若干线程之间形成一种头尾相接的循环等待资源关系。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="诊断死锁">诊断死锁</h4><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310185626352.png" alt="image-20240310185626352" style="zoom:67%;" /><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310185932837.png" alt="image-20240310185932837" style="zoom:67%;" /><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310185656573.png" alt="image-20240310185656573" style="zoom:67%;" /><h3 id="乐观锁">乐观锁</h3><ul class="lvl-0"><li class="lvl-2"><p>乐观锁的基本思想是认为数据在一般情况下不会发生冲突，因此在访问数据时不加锁，而是在更新数据时检查是否发生了冲突。如果发现冲突，会进行相应的处理（通常是回滚操作），然后重新尝试。</p></li><li class="lvl-2"><p>乐观锁的典型实现是<strong>版本号机制</strong>、<strong>CAS算法</strong><mark>（是一个原子操作）</mark>。</p><ul class="lvl-2"><li class="lvl-4">在 Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</li></ul></li></ul><h4 id="悲观锁乐观锁如何选择">悲观锁乐观锁如何选择</h4><p>悲观锁适用于并发写入较多的场景，能够确保数据的一致性；而乐观锁适用于并发读取较多、写入较少的场景，可以提高系统的并发性能。</p><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试（<strong>黑马点评，超卖问题的解决</strong>），这样同样会非常影响性能，导致 CPU 飙升。</p><p><strong>悲观锁</strong>通常多用于<strong>写比较多</strong>的情况（<strong>多写场景</strong>，竞争激烈），这样可以<strong>避免频繁失败和重试</strong>影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</p><p><strong>乐观锁</strong>通常多用于<strong>写比较少</strong>的情况（多读场景，竞争较少），这样可以<strong>避免频繁加锁</strong>影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）</p><h4 id="CAS（Compare-And-Swap">CAS（Compare And Swap)</h4><p>​</p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310152254760.png" alt="image-20240310152254760" style="zoom:67%;" /><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310153314915.png" alt="image-20240310153314915" style="zoom:67%;" /><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><p><mark>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</mark></p><blockquote><p><strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p></blockquote><p>CAS 涉及到三个操作数：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>V</strong>：要更新的变量值(Var)</p></li><li class="lvl-2"><p><strong>E</strong>：预期值(Expected)</p></li><li class="lvl-2"><p><strong>N</strong>：拟写入的新值(New)</p></li></ul><p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p><h4 id="CAS存在的问题">CAS存在的问题</h4><ul class="lvl-0"><li class="lvl-2"><p>ABA问题，利用版本号机制可以解决</p></li><li class="lvl-2"><p>自旋问题，循环时间长开销大：当操作不成功的时候会一直自旋，直到操作成功，会占用过多CPU资源</p></li><li class="lvl-2"><p>只能保证一个共享变量的原子操作：只对单个共享变量有效，当涉及到多个共享变量CAS无效</p></li></ul><h2 id="多线程的执行安全">多线程的执行安全</h2><p><strong>要确保三大特性：原子性、可见性、有序性</strong></p><h3 id="原子性">原子性</h3><p>一个线程在CPU中操作不可暂停，也不可中断，要不执行完成，要不不执行</p><p>实现方案： 加锁</p><ol><li class="lvl-3"><p>synchronized：同步加锁</p></li><li class="lvl-3"><p>JUC里面的lock：加锁</p></li></ol><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310193152560.png" alt="image-20240310193152560" style="zoom:67%;" /><h3 id="可见性">可见性</h3><p>让一个线程对共享变量的修改对另一个线程可见</p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310193255054.png" alt="image-20240310193255054" style="zoom:67%;" /><h3 id="有序性">有序性</h3><p>指令重排：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的</p><p>要避免指令重排：volatile</p><h2 id="线程池">线程池</h2><h3 id="线程池参数、原理-⭐">线程池参数、原理  ⭐</h3><p><strong>什么是线程池?</strong></p><p>顾名思义，线程池就是管理一系列线程的<strong>资源池</strong>。当有任务要处理时，直接从线程池中获取线程来处理，**处理完之后线程并不会立即被销毁，而是等待下一个任务。**池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p><strong>使用线程池的好处</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p></li><li class="lvl-2"><p><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p></li><li class="lvl-2"><p><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p></li></ul><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310193949527.png" alt="image-20240310193949527" style="zoom:67%;" /><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310194453585.png" alt="image-20240310194453585"></p><p>1，任务在提交的时候，首先判断核心线程数是否已满，如果没有满则直接添加到工作线程执行</p><p>2，如果核心线程数满了，则判断阻塞队列是否已满，如果没有满，当前任务存入阻塞队列</p><p>3，如果阻塞队列也满了，则判断线程数是否小于最大线程数，如果满足条件，则使用临时线程执行任务</p><p>核心或临时线程执行完成任务后会检查阻塞队列中是否有需要执行的线程，如果有，则使用非核心线程执行任务</p><p>4，如果所有线程都在忙着（核心线程+临时线程），则走拒绝策略</p><h3 id="拒绝策略">拒绝策略</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>AbortPolicy</strong>：抛出<code>RejectedExecutionException</code>异常来拒绝新任务</p></li><li class="lvl-2"><p><strong>CallerRunsPolicy</strong>：调用执行自己的线程运行任务，也就是在调用execute()方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。<strong>该策略会降低对于新任务的提交速度</strong>，影响程序的整体性能。</p></li><li class="lvl-2"><p><strong>DiscardPolicy</strong>：不处理新任务，直接丢弃掉</p></li><li class="lvl-2"><p><strong>DiscardOldestPolicy</strong>：丢弃掉最早未处理的任务</p></li></ul><h3 id="线程池常用的阻塞队列">线程池常用的阻塞队列</h3><p>比较常见的有4个，用的最多是ArrayBlockingQueue和LinkedBlockingQueue</p><p><strong>1.ArrayBlockingQueue</strong>：基于数组结构的有界阻塞队列，FIFO。</p><p><strong>2.LinkedBlockingQueue</strong>：基于链表结构的有界阻塞队列，FIFO。</p><p><strong>3.DelayedWorkQueue</strong> ：延时队列，是一个<strong>优先级队列</strong>，可以实现<strong>定时任务</strong>，它可以保证每次出队的任务都是当前队列中执行时间最靠前的</p><p><strong>4.SynchronousQueue</strong>：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p><p><strong>ArrayBlockingQueue的LinkedBlockingQueue区别</strong></p><table><thead><tr><th><strong>LinkedBlockingQueue</strong></th><th><strong>ArrayBlockingQueue</strong></th></tr></thead><tbody><tr><td>默认无界，支持有界</td><td>强制有界</td></tr><tr><td>底层是链表</td><td>底层是数组</td></tr><tr><td>是懒惰的，创建节点的时候添加数据</td><td>提前初始化 Node  数组</td></tr><tr><td>入队会生成新 Node</td><td>Node需要是提前创建好的</td></tr><tr><td><strong>两把锁（头尾）</strong></td><td><strong>一把锁</strong></td></tr></tbody></table><p>左边是LinkedBlockingQueue加锁的方式，右边是ArrayBlockingQueue加锁的方式</p><ul class="lvl-0"><li class="lvl-2"><p>LinkedBlockingQueue<strong>读和写各有一把锁</strong>，性能相对较好</p></li><li class="lvl-2"><p>ArrayBlockingQueue只有一把锁，读和写公用，性能相对于LinkedBlockingQueue差一些</p></li></ul><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310200853628.png" alt="image-20240310200853628"></p><h3 id="如何确定核心线程数？">如何确定核心线程数？</h3><p>在设置核心线程数之前，需要先熟悉一些执行线程池执行任务的类型</p><ul class="lvl-0"><li class="lvl-2"><p>IO密集型任务</p></li></ul><p>一般来说：文件读写、DB读写、网络请求等</p><p>推荐：核心线程数大小设置为  <strong>2N+1</strong>    （N为计算机的CPU核数）</p><ul class="lvl-0"><li class="lvl-2"><p>CPU密集型任务</p></li></ul><p>一般来说：计算型代码、Bitmap转换、Gson转换等</p><p>推荐：核心线程数大小设置为  <strong>N+1</strong>    （N为计算机的CPU核数）</p><p>有一个简单并且适用面比较广的公式：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p></li><li class="lvl-2"><p><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p></li></ul><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><p><strong>参考回答：</strong></p><p>① 高并发、任务执行时间短 --&gt;（ CPU核数+1 ），减少线程上下文的切换</p><p>② 并发不高、任务执行时间长</p><ul class="lvl-0"><li class="lvl-2"><p>IO密集型的任务 --&gt; (CPU核数 * 2 + 1)</p></li><li class="lvl-2"><p>计算密集型任务 --&gt; （ CPU核数+1 ）</p></li></ul><p>③ 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）</p><h3 id="线程池的种类">线程池的种类</h3><p>在java.util.concurrent.Executors类中提供了大量创建连接池的静态方法，常见就有四种</p><h4 id="newFixedThreadPool">newFixedThreadPool</h4><p>创建使用固定线程数的线程池</p><p>源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>核心线程数与最大线程数一样，没有救急线程</p></li><li class="lvl-2"><p>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</p></li><li class="lvl-2"><p>适用场景：适用于<strong>任务量已知，相对耗时</strong>的任务</p></li></ul><p>即使 <code>maximumPoolSize</code> 的值比 <code>corePoolSize</code> 大，也至多只会创建 <code>corePoolSize</code> 个线程。这是因为<code>FixedThreadPool</code> 使用的是容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列），队列永远不会被放满。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FixedThreadDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个固定大小的线程池，核心线程数和最大线程数都是3</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> <span class="title class_">FixedThreadDemo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="newSingleThreadExecutor">newSingleThreadExecutor</h4><p><strong>单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO)执行</strong></p><p>源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">           (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                   <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                   threadFactory));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>核心线程数和最大线程数都是1</p></li><li class="lvl-2"><p>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</p></li><li class="lvl-2"><p>适用场景：<strong>适用于按照顺序执行的任务</strong></p></li></ul><p><code>SingleThreadExecutor</code> 和 <code>FixedThreadPool</code> 一样，使用的都是容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）作为线程池的工作队列。<code>SingleThreadExecutor</code> 使用无界队列作为线程池的工作队列会对线程池带来的影响与 <code>FixedThreadPool</code> 相同。说简单点，就是可能会导致 <strong>OOM</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewSingleThreadCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//单个线程池，核心线程数和最大线程数都是1</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Demo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="newCachedThreadPool">newCachedThreadPool</h4><p>可缓存线程池</p><p>源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>核心线程数为0</p></li><li class="lvl-2"><p>最大线程数是Integer.MAX_VALUE</p></li><li class="lvl-2"><p>阻塞队列为SynchronousQueue:不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p></li><li class="lvl-2"><p>适用场景：适合任务数比较密集，但每个任务执行时间较短的情况</p></li></ul><p><code>CachedThreadPool</code> 的<code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code>被设置为 <code>Integer.MAX.VALUE</code>，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//修改睡眠时间，模拟线程执行需要花费的时间</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(name + <span class="string">&quot;执行完了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个缓存的线程，没有核心线程数，最大线程数为Integer.MAX_VALUE</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Demo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="newScheduledThreadPool">newScheduledThreadPool</h4><p>提供了“延迟”和“周期执行”功能的ThreadPoolExecutor。</p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20230505222203615.png" alt="image-20230505222203615"></p><ul class="lvl-0"><li class="lvl-2"><p>适用场景：有定时和延迟执行的任务</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">                System.out.println(name + <span class="string">&quot;, 开始：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;, 结束：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//按照周期执行的线程池，核心线程数为2，最大线程数为Integer.MAX_VALUE</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * schedule 提交任务到线程池中</span></span><br><span class="line"><span class="comment">         * 第一个参数：提交的任务</span></span><br><span class="line"><span class="comment">         * 第二个参数：任务执行的延迟时间</span></span><br><span class="line"><span class="comment">         * 第三个参数：时间单位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">0</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        scheduledThreadPool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么不建议用Executors创建线程池？">为什么不建议用Executors创建线程池？</h3><p>Executors创建的线程池，最大线程数等于核心线程数，并且请求队列无界，可能会造成OOM</p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20240310204839377.png" alt="image-20240310204839377" style="zoom:67%;" /><h3 id="execute-vs-submit-⭐">execute()  vs  submit() ⭐</h3><ul class="lvl-0"><li class="lvl-2"><p><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</p></li><li class="lvl-2"><p><code>submit()</code>方法用于提交需要返回值的任务。<mark>线程池会返回一个 <code>Future</code> 类型的对象</mark>，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<mark><code>get()</code>方法会阻塞当前线程直到任务完成</mark>，而使用 <code>get（long timeout，TimeUnit unit）</code>方法的话，如果在 <code>timeout</code> 时间内任务还没有执行完，就会抛出 <code>java.util.concurrent.TimeoutException</code>。</p></li></ul><p>这里只是为了演示使用，推荐使用 <code>ThreadPoolExecutor</code> 构造方法来创建线程池。</p><p>示例 1：使用 <code>get()</code>方法获取返回值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; submit = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> submit.get();</span><br><span class="line">System.out.println(s);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure><h3 id="shutdown-VS-shutdownNow">shutdown() VS shutdownNow()</h3><ul class="lvl-0"><li class="lvl-2"><p><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。<strong>线程池不再接受新任务了</strong>，但是<strong>队列里的任务得执行完毕。</strong></p></li><li class="lvl-2"><p><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程池的状态变为 <code>STOP</code>。线程池会<strong>终止当前正在运行的任务</strong>，并停止处理排队的任务并<strong>返回正在等待执行的 List</strong>。</p></li></ul><p>调用完 <code>shutdownNow</code> 和 <code>shuwdown</code> 方法后，并不代表线程池已经完成关闭操作，它只是异步的通知线程池进行关闭处理。如果要同步等待线程池彻底关闭后才继续往下执行，需要调用<code>awaitTermination</code>方法进行同步等待。</p><p>在调用 <code>awaitTermination()</code> 方法时，应该设置合理的超时时间，以避免程序长时间阻塞而导致性能问题。另外。由于线程池中的任务可能会被取消或抛出异常，因此在使用 <code>awaitTermination()</code> 方法时还需要进行异常处理。<code>awaitTermination()</code> 方法会抛出 <code>InterruptedException</code> 异常，需要捕获并处理该异常，以避免程序崩溃或者无法正常退出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">executor.shutdown();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 等待线程池关闭，最多等待5分钟</span></span><br><span class="line">    <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">5</span>, TimeUnit.MINUTES)) &#123;</span><br><span class="line">        <span class="comment">// 如果等待超时，则打印日志</span></span><br><span class="line">        System.err.println(<span class="string">&quot;线程池未能在5分钟内完全关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isTerminated-VS-isShutdown">isTerminated()  VS  isShutdown()</h3><ul class="lvl-0"><li class="lvl-2"><p><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</p></li><li class="lvl-2"><p><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</p></li></ul><h3 id="线程工厂">线程工厂</h3><p>默认情况下创建的线程名字类似 <code>pool-1-thread-n</code> 这样的，没有业务含义，不利于我们定位问题。</p><p>给线程池里的线程命名通常有下面两种方式：</p><p><strong>1、利用 guava 的 <code>ThreadFactoryBuilder</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                        .setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2、自己实现 <code>ThreadFactory</code>。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NamingThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个带名字的线程池生产工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NamingThreadFactory</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        t.setName(name + <span class="string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ThreadLocal">ThreadLocal</h2><h3 id="概述">概述</h3><p>ThreadLocal是多线程中对于<strong>解决线程安全</strong>的一个操作类，它会为每个线程都分配一个独立的线程副本从而解决了变量并发访问冲突的问题。ThreadLocal 同时实现了线程内的资源共享</p><p>案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的 Connection 上进行数据库的操作，避免A线程关闭了B线程的连接。</p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20230505224057228.png" alt="image-20230505224057228"></p><h3 id="ThreadLocal基本使用">ThreadLocal基本使用</h3><p>三个主要方法：</p><ul class="lvl-0"><li class="lvl-2"><p>set(value) 设置值</p></li><li class="lvl-2"><p>get() 获取值</p></li><li class="lvl-2"><p>remove() 清除值</p></li></ul><h3 id="ThreadLocal的实现原理-源码解析">ThreadLocal的实现原理&amp;源码解析</h3><p>从 <code>Thread</code>类源代码入手。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p><p>ThreadLocal本质来说就是一个线程内部存储类，从而让多个线程只操作自己内部的值，从而实现线程数据隔离</p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20230505224341410.png" alt="image-20230505224341410"></p><p>在ThreadLocal中有一个内部类叫做ThreadLocalMap，类似于HashMap</p><p>ThreadLocalMap中有一个属性table数组，这个是真正存储数据的位置</p><p><strong>set方法</strong></p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20230505224626253.png" alt="image-20230505224626253"></p><p><strong>get方法/remove方法</strong></p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20230505224715087.png" alt="image-20230505224715087"></p><p>通过上面这些内容，我们足以通过得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong><code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p><p><mark>实际上<code>key</code>并不是<code>ThreadLocal</code>本身，而是它的一个<strong>弱引用</strong></mark></p><h3 id="ThreadLocal-内存泄露问题">ThreadLocal-内存泄露问题</h3><p>Java对象中的四种引用类型：强引用、软引用、弱引用、虚引用</p><ul class="lvl-0"><li class="lvl-2"><p>强引用：最为普通的引用方式，表示一个对象处于有用且必须的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，<strong>宁可出现OOM，也不会对其进行回收</strong></p></li></ul><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20230505224755797.png" alt="image-20230505224755797"></p><ul class="lvl-0"><li class="lvl-2"><p>弱引用：表示一个对象处于可能有用且非必须的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收</p></li></ul><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20230505224812015.png" alt="image-20230505224812015"></p><p>每一个Thread维护一个ThreadLocalMap，在ThreadLocalMap中的Entry对象继承了WeakReference。其中key为使用弱引用的ThreadLocal实例，value为线程变量的副本</p><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</p><p><img src="https://neo-typora.oss-cn-nanjing.aliyuncs.com/images/blog_images%2FJUC.assets%2Fimage-20230505224857538.png" alt="image-20230505224857538"></p><p>在使用ThreadLocal的时候，强烈建议：<strong>务必手动remove</strong></p><p><strong>实际上：</strong></p><p>ThreadLocal的源码中设计了自动清理key为null的entry的代码逻辑。主要逻辑如下：</p><p>调用 <code>set()</code> 方法后，有以下几种情况：</p><p><strong>情况1</strong>：通过 hash 计算后，Entry 数组对应的槽位为空，这种情况直接插入 key-value</p><p>**情况2：**发生了哈希冲突，且槽位数据不为空，但槽位中的 key 与要插入的 key 相同，这种情况直接覆盖元数据。</p><p><strong>情况3：<strong>发生了哈希冲突，槽位数据不为空，槽位中的key与当前要插入的key不同，则进行</strong>线性探测</strong>，向后进行查找：</p><p><strong>情况3.1</strong>：探测过程中，遇到空Entry，则直接插入</p><p>**情况3.2：**探测过程中，遇到key相同的Entry，则直接覆盖</p><p><strong>情况3.3：<strong>探测过程中，遇到 key = null 的槽位，槽位下标为 i，则调用 replaceStaleEntry() 方法，<code>slotToExpunge = staleSlot = i</code>，然后从当前位置向前进行探测，遇到key = null的槽位，则更新slotToExpunge的值，直到Entry为null，然后以 staleSlot 为起始位置</strong>向后进行探测</strong>：</p><p>**情况3.3.1：**如果找到key相同的entry则直接覆盖，然后交换 <code>table[i]</code> 和<code>table[staleSlot]</code> 的数据</p><p>**情况3.3.2：**如果找到空槽，则直接插入，然后与table[staleSlot]交换位置</p><p>插入后，开始进行过期元素的清理。</p><p><strong>清理过期元素的方法有</strong>：探测式清理、启发式清理</p><p>探测式清理从<code>slotToExpunge</code>开始向后清除过期元素，同时将没有过期的元素进行重新哈希，更新元素的位置，如果发生了哈冲突，则向后进行线性探测</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
